function e(e,t,r,i){Object.defineProperty(e,t,{get:r,set:i,enumerable:!0,configurable:!0})}var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},r={},i={},o=t.parcelRequire4485;null==o&&((o=function(e){if(e in r)return r[e].exports;if(e in i){var t=i[e];delete i[e];var o={id:e,exports:{}};return r[e]=o,t.call(o.exports,o,o.exports),o.exports}var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}).register=function(e,t){i[e]=t},t.parcelRequire4485=o),o.register("7ePFa",(function(t,r){e(t.exports,"mergeBufferGeometries",(()=>n)),e(t.exports,"mergeVertices",(()=>u));var i=o("ilwiq");function n(e,t=!1){const r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},l={},f=e[0].morphTargetsRelative,a=new i.BufferGeometry;let m=0;for(let i=0;i<e.length;++i){const s=e[i];let c=0;if(r!==(null!==s.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in s.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[e]&&(u[e]=[]),u[e].push(s.attributes[e]),c++}if(c!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(f!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in s.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[e]&&(l[e]=[]),l[e].push(s.morphAttributes[e])}if(t){let e;if(r)e=s.index.count;else{if(void 0===s.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;e=s.attributes.position.count}a.addGroup(m,e,i),m+=e}}if(r){let t=0;const r=[];for(let i=0;i<e.length;++i){const o=e[i].index;for(let e=0;e<o.count;++e)r.push(o.getX(e)+t);t+=e[i].attributes.position.count}a.setIndex(r)}for(const e in u){const t=s(u[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;a.setAttribute(e,t)}for(const e in l){const t=l[e][0].length;if(0===t)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let i=0;i<l[e].length;++i)t.push(l[e][i][r]);const i=s(t);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;a.morphAttributes[e].push(i)}}return a}function s(e){let t,r,o,n=0;for(let i=0;i<e.length;++i){const s=e[i];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=s.normalized),o!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;n+=s.array.length}const s=new t(n);let u=0;for(let t=0;t<e.length;++t)s.set(e[t].array,u),u+=e[t].array.length;return new i.BufferAttribute(s,r,o)}function u(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},o=e.getIndex(),n=e.getAttribute("position"),s=o?o.count:n.count;let u=0;const l=Object.keys(e.attributes),f={},a={},m=[],c=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"];for(let t=0,r=l.length;t<r;t++){const r=l[t],o=e.attributes[r];f[r]=new i.BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const n=e.morphAttributes[r];n&&(a[r]=new i.BufferAttribute(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized))}const b=Math.log10(1/t),h=Math.pow(10,b);for(let t=0;t<s;t++){const i=o?o.getX(t):t;let n="";for(let t=0,r=l.length;t<r;t++){const r=l[t],o=e.getAttribute(r),s=o.itemSize;for(let e=0;e<s;e++)n+=~~(o[c[e]](i)*h)+","}if(n in r)m.push(r[n]);else{for(let t=0,r=l.length;t<r;t++){const r=l[t],o=e.getAttribute(r),n=e.morphAttributes[r],s=o.itemSize,m=f[r],b=a[r];for(let e=0;e<s;e++){const t=c[e],r=g[e];if(m[r](u,o[t](i)),n)for(let e=0,o=n.length;e<o;e++)b[e][r](u,n[e][t](i))}}r[n]=u,m.push(u),u++}}const d=e.clone();for(const t in e.attributes){const e=f[t];if(d.setAttribute(t,new i.BufferAttribute(e.array.slice(0,u*e.itemSize),e.itemSize,e.normalized)),t in a)for(let e=0;e<a[t].length;e++){const r=a[t][e];d.morphAttributes[t][e]=new i.BufferAttribute(r.array.slice(0,u*r.itemSize),r.itemSize,r.normalized)}}return d.setIndex(m),d}}));
//# sourceMappingURL=characterMovement.3a4c9749.js.map
